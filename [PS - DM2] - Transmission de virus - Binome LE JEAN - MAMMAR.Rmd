---
title: "[PS - DM2] - Transmission de virus"
output: html_document
---
**Binôme : Malek MAMMAR & Alexandre LE JEAN**

Dans ce DM nous nous efforcerons cette fois-ci a fournir une description plus détailler de notre démarche suite a la remarque de Arnaud Legrand.

**Question 1**

Etudions Tn en fonction de N quand le graphe est complet : 

Choix de representation de notre structure de graphe : 
On souhaite tirer uniformément sur notre ensemble d'arêtes :
  
  representation 1 : matrice d'adjacence contenant 1 ou 0 pour respectivement l'existence ou l'absence d'arête entre les sommets d'indice (i,j). A cela on ajoutera la representation 2 qui contiendra l'information de si un sommet est infecté ou non.
  
  representation 2 : un simple tableau contenant 1 ou 0 si respectivement le sommet d'indice i est infecté ou non.

Dans cette question on est en présence d'un graphe complet, la representation 2 à elle seule suffit car quelque soit le couple de sommet tiré il existe une forcément une arête les reliants. 

```{r}
#Cette fonction renvoie un tableau de sommets dont 1 sommet est infecté
generateur_graphe_complet <- function (N = 10) {
  graphe = array(0, N)
  premier_sommet_infecte = floor(runif(n = 1, min = 1, max = N+1))
  graphe[premier_sommet_infecte] = 1;
  graphe
}

generateur_graphe_complet()

```

```{r}

#Cette fonction tire uniformement une arete de notre graphe complet
generateur_arete_complet <- function (N = 10) {
  #on repete jusqu'à ne pas avoir un boucle
  repeat {
    arete = floor(runif(n = 2, min = 1, max = N+1))
    if (arete[1] != arete[2]) break
  }
  
  arete
}

generateur_arete_complet()

```


```{r}
set.seed(42)

#Lancement de la simulation
simulation1 <- function( N = 10, generateur_arete ) {

  graphe = generateur_graphe_complet(N);
  nbSommetInfecté = 1;
  T_N = 0;

  df = data.frame(Temps = c(T_N), nbInfecté = c(nbSommetInfecté))
  while ( nbSommetInfecté < N ) {
    arete = generateur_arete(N);
    x = arete[1];
    y = arete[2];

    if ((graphe[x] == 1) || (graphe[y] == 1)) {
      
      #Si x et y ne sont pas tous les deux infectés
      if (! ((graphe[x] == 1) && (graphe[y] == 1)) ) { 
        nbSommetInfecté = nbSommetInfecté + 1;
      }
      graphe[x] = 1;
      graphe[y] = 1;
    }
    
    T_N = T_N + 1;
    df = rbind(df, data.frame(Temps = T_N, nbInfecté = nbSommetInfecté))
  }
  
  df
}

```

Observons l'évolution de $T_N$ en fonction de N :
```{r}
library(ggplot2)
set.seed(42);

df2 = data.frame(N = c(), T_N = c())
for(samples in 1:10) {
  Ni = samples * 10
  df2 = rbind(df2, data.frame(N = Ni, T_N = tail(simulation1(Ni, generateur_arete_complet), 1)$Temps ))
}

df2
#plot(df)
ggplot(data=df2, aes(x=N)) + geom_line(data=df2,aes(y=T_N),color="red") + theme_bw()
```

Conclusion :
Dans ce cas d'un graphe complet on peut remarquer que le temps nécessaire pour que toute la population soit infectée évolue grossièrement de façon logarithmique par rapport a l'effectif de la population. Ce qui nous pensons expliquerait la decroissance entre 800 et 900.

Il serait interessant de tracer la courbe épidemique afin d'avoir une idée de comment est ce que le virus sur propage sur une population N

```{r}
library(ggplot2)
set.seed(42);

N = 1000
df = simulation1(N, generateur_arete_complet)
ggplot(data=df, aes(x=Temps)) + geom_line(data=df,aes(y=nbInfecté),color="red") + theme_bw()
```

Conclusion:
On remarque la contamination évolue de manière exponentielle dès l'infection d'une infime partie de la population ici au temps 0 seule 1 personne est infectée. 
En l'espace de 4000 unités de temps la moitié de la population est déjà infectée et 2000 unités de temps plus tards toute la population est quasi infectée.
On ne que rester stupéfait devant la rapidité de l'infection dans un graphe connexe.

**Question 2**

Graphe ligne 1D et grille 2D

1. Lorsque le graphe est une ligne :

```{r}
#Generateur de graphe en ligne
#Cette fonction renvoie un tableau de sommets dont 1 sommet est infecté
generateur_graphe_ligne <- function (N = 10) {
  generateur_graphe_complet(N)
}

```

```{r}
#Cette fonction tire uniformement une arete de notre graphe en ligne
gene_arete_ligne <- function (N = 10) {
  x = floor(runif(n = 1, min = 1, max = N)) #On tire uniformement x sur [0..N-1]
  y = x+1
  c(x, y)
}

#Cette fonction tire uniformement une arete de notre graphe en ligne avec tore
gene_arete_ligne_tore <- function (N = 10) {
  x = floor(runif(n = 1, min = 1, max = N+1)) #On tire uniformement x sur [0..N]
  if (x == N)
    y = 1
  else
    y = (x+1)
  
  c(x, y)
}
```



```{r}
evolution_T_N <- function (simulateur, generateur, pas, nbSamples) {
  library(ggplot2)
  set.seed(42);
  
  df2 = data.frame(N = c(), T_N = c())
  for(samples in 1:nbSamples) {
    Ni = samples * pas
    df2 = rbind(df2, data.frame(N = Ni, T_N = tail(simulateur(Ni, generateur), 1)$Temps ))
  }
  
  df2
  ggplot(data=df2, aes(x=N)) + geom_line(data=df2,aes(y=T_N),color="red") + theme_bw()
}
```


```{r}
courbe_epidemique <- function (simulteur, generateur, N) { 
  library(ggplot2)
  set.seed(42);
  
  df = simulation1(N, generateur)
  ggplot(data=df, aes(x=Temps)) + geom_line(data=df,aes(y=nbInfecté),color="red") + theme_bw()
}
```

Réitérons notre simulation et observons l'évolution de $T_N$ en fonction de N sur un graphe 1D : Sans tore

```{r}
evolution_T_N(simulateur = simulation1, generateur = gene_arete_ligne, pas = 10, nbSamples = 10)

```

La courbe épidemique :
```{r}
courbe_epidemique(simulteur = simulation1, generateur = gene_arete_ligne, N = 100)
```


Réitérons notre simulation et observons l'évolution de $T_N$ en fonction de N sur un graphe 1D Avec tore
```{r}
evolution_T_N(simulateur = simulation1, generateur = gene_arete_ligne_tore, pas = 10, nbSamples = 10)

```

La courbe épidemique :
```{r}
courbe_epidemique(simulteur = simulation1, generateur = gene_arete_ligne_tore, N = 100)
```


2. Lorsque le graphe est une grille 2D : 
 
 Pour notre choix de modélisation :
 On peut distinguer deux types d'arêtes : les arêtes verticales, et les arêtes horizontales (Voir l'exemple ci-contre) : ![title](ps_dm2.png)
 
 Soient M : la hauteur, N : la largeur et N*M le nombre de sommets
 Le nombre d'arêtes noté #arete est $#arete = 2NM-N-M$
  - Dans le cas sans tore : 
  
  Le tirage uniforme se fait comme suit :
  
```{r}
gene_arete_grille <- function (N, M) {
  nbArete = 2*N*M - N - M
  nbSommet = N * M
  x = floor(runif(n = 1, min = 1, max = nbArete + 1))
  
  if ( x <= ((N-1)*M)) {
    #On est dans les arêtes horizontales
    y = x + 1
  } else {
    #On est dans les arêtes verticales
    x = x - ((N-1) * M)
    y = x + N
  }
  
  c(x,y)
}

```

  - Dans le cas AVEC tore : 
  
  Le tirage uniforme se fait comme suit :
  
```{r}
gene_arete_grille_tore <- function (N, M) {
  nbArete = 2*N*M - N - M
  nbSommet = N * M
  x = floor(runif(n = 1, min = 1, max = nbArete + 1))
  
  if ( x <= (N*M)) {
    #On est dans les arêtes horizontales
    if ((x%N) == 0) {
      #On est sur la colonne la plus a droite de la grille
      y = ceiling(x/N)
    } else {
      y = x + 1  
    }
    
  } else {
    #On est dans les arêtes verticales
    x = x - N*M
    if (x > (2*M*N - N)) {
      #On est sur la ligne la plus en bas de la grille
      y = x %% N
    } else {
        y = x + N      
    }
  }
  
  c(x,y)
}

```
